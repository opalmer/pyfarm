#!/usr/bin/env python
#
# Copyright 2013 Oliver Palmer
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
run commands and manage host information and resources
"""

import os
import sys
import time

CWD = os.path.realpath(os.path.dirname(__file__))

try:
    import pyfarm

except ImportError: # mainly for testing
    import site
    import warnings
    warnings.warn("adding PyFarm to the site packages", RuntimeWarning)
    root = os.path.realpath(os.path.join(CWD, '..'))
    sitedir = os.environ.get('PYFARM_PYTHONLIB') or\
              os.path.join(root, 'lib', 'python')

    if not os.path.isdir(sitedir):
        raise OSError(
            "no such directory %s, cannot add to site directory" % sitedir
        )
    site.addsitedir(sitedir)

from pyfarm.host import cmdargs
from pyfarm import lock
from pyfarm import logger as _logger
from pyfarm.preferences import prefs
from pyfarm.datatypes.network import FQDN
from pyfarm.datatypes.enums import OperatingSystem

# Handle command line input before importing anything else.  This
# ensures that if -h or --help is requested or if we have trouble
# parsing the arguments we can run the appropriate action before
# we setup other modules.
options = cmdargs.parser.parse_args()

if options.db is not None:
    prefs.set('database.setup.config', options.db)

# determine the location we should log to
if not options.log:
    root = prefs.get('filesystem.locations.general')
    SERVICE_LOG = os.path.join(root, 'host-%s.log' % FQDN)
else:
    SERVICE_LOG = os.path.abspath(options.log)

_logger.logger.addObserver(_logger.Observer(SERVICE_LOG))
logger = _logger.logger

# setup the process lock before starting the log
PROCESS_LOCK = lock.ProcessLock(
    'host',
    kill=options.force_kill, wait=options.wait,
    remove=options.remove_lock
)

from pyfarm import errors
from pyfarm.host import master
from pyfarm.db import insert, modify, query
from pyfarm.db.modify.host import update_memory
from pyfarm.datatypes.system import OS
from pyfarm.datatypes import network
from pyfarm.net.rpc.client import utility
from pyfarm.net.rpc.server.xmlservice import XMLRPCService

from twisted.internet import reactor, task
from twisted.web import server as _server

CWD = os.getcwd()
MASTER = ()
SERVICE = None

# PYFARM_RESTART should not start out in the environment
if 'PYFARM_RESTART' in os.environ:
    del os.environ['PYFARM_RESTART']

class Host(XMLRPCService, _logger.Logger):
    '''
    Main xmlrpc service which controls the host.  Most methods
    are handled entirely outside of this class for the purposes of
    separation of service and logic.
    '''
    # provides a location to store our call to reactor.callLater
    def __init__(self):
        _logger.Logger.__init__(self, self)
        XMLRPCService.__init__(self, SERVICE_LOG)

        cmdargs.printOptions(options, self.debug)

        if options.verify_master:
            if not utility.ping(MASTER[0], MASTER[1]):
                raise errors.NetworkSetupError(
                    "failed to connect to master at %s:%s" % MASTER
                )

            try:
                online = query.master.online(MASTER[0])
                if not online:
                    raise errors.NetworkSetupError(
                        "%s:%s is not online but is reachable" % MASTER
                    )

            except errors.HostNotFound, error:
                raise errors.NetworkSetupError(error)
    # end __init__

    def xmlrpc_master(self):
        '''returns the current master'''
        return MASTER
    # end xmlrpc_master

    def _blockShutdown(self):
        return False
    # end _blockShutdown

    def _blockRestart(self):
        return self._blockShutdown()
    # end _blockRestart
# end Client

# create a lock for the process so we can't run two clients
# from the same host at once
with PROCESS_LOCK:
    # if the master has not been provided then
    # we should try and use the entry from the database
    master = master.get(options.master)
    master_port = query.master.port(master)
    MASTER = (master, master_port)

    # construct keyword arguments used to update the host in
    # the database
    host_table_keywords = {
        "ram_total" : options.ram,
        "cpus" : options.cpus,
        "online" : options.online,
        "groups" : options.groups,
        "software" : options.software,
        "port" : options.port
    }

    if options.store_master and options.master:
        host_table_keywords['master'] = options.master

    elif options.store_master and options.master is None:
        logger.warning("master will be set to None for %s" % FQDN)
        host_table_keywords['master'] = options.master

    if query.hosts.exists():
        logger.debug("updating %s in the host table" % FQDN)
        modify.host.host(
            FQDN,
            **host_table_keywords
        )

    else:
        logger.info("inserting %s into the host table" % FQDN)
        insert.host.host(**host_table_keywords)

    SERVICE = Host()

    # assign the host id
    network.HOSTNAME = query.hosts.hostid(network.FQDN)

    # schedule memory updates
    update_memory_task = task.LoopingCall(update_memory.update)
    update_memory_task.start(prefs.get('host.ram-update-interval'), now=False)

    # start listening for connections with the host
    reactor.listenTCP(options.port, _server.Site(SERVICE))

    # start reactor
    args = (FQDN, options.port)
    SERVICE.info("running host at http://%s:%i" % args)
    reactor.run()

    # set this host as offline
    SERVICE.debug("setting host as offline in database")
    modify.host.host(FQDN, online=False)

# If RESTART has been set to True then restart the host
# script.  This must be done after the reactor and has been
# shutdown and after we have given the port(s) a chance
# to release.
if os.environ.get('PYFARM_RESTART') == 'true' and prefs.get('network.rpc.restart'):
    pause = prefs.get('network.rpc.delay')
    SERVICE.debug("preparing to restart the host, pausing %i seconds" % pause)
    time.sleep(pause)
    args = sys.argv[:]

    args.insert(0, sys.executable)
    if OS == OperatingSystem.WINDOWS:
        args = ['"%s"' % arg for arg in args]

    os.chdir(CWD)
    os.execv(sys.executable, args)
