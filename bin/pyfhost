#!/usr/bin/env python
#
# This file is part of PyFarm.
# Copyright (C) 2008-2012 Oliver Palmer
#
# PyFarm is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PyFarm is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with PyFarm.  If not, see <http://www.gnu.org/licenses/>.

'''
run commands and manage host information and resources
'''

import os
import sys
import time
import site

CWD = os.path.realpath(os.path.dirname(__file__))
ROOT = os.path.realpath(os.path.join(CWD, '..'))
PYTHONLIB = os.environ.get('PYFARM_PYTHONLIB') or os.path.join(ROOT, 'lib', 'python')
site.addsitedir(PYTHONLIB)

from pyfarm.host import cmdargs
from pyfarm import lock
from pyfarm import logger as _logger
from pyfarm.preferences import prefs
from pyfarm.datatypes.network import FQDN

# Handle command line input before importing anything else.  This
# ensures that if -h or --help is requested or if we have trouble
# parsing the arguments we can run the appropriate action before
# we setup other modules.
options = cmdargs.parser.parse_args()

if options.db is not None:
    prefs.set('database.setup.config', options.db)

# determine the location we should log to
if not options.log:
    root = prefs.get('filesystem.locations.general')
    SERVICE_LOG = os.path.join(root, 'host-%s.log' % FQDN)
else:
    SERVICE_LOG = os.path.abspath(options.log)

_logger.logger.addObserver(_logger.Observer(SERVICE_LOG))
logger = _logger.logger

# setup the process lock before starting the log
PROCESS_LOCK = lock.ProcessLock(
    'host',
    kill=options.force_kill, wait=options.wait,
    remove=options.remove_lock
)

from pyfarm import errors
from pyfarm.host import master
from pyfarm.db import insert, modify, query
from pyfarm.db.modify.host import update_memory
from pyfarm.datatypes.system import OS, OperatingSystem
from pyfarm.datatypes import network
from pyfarm.net import rpc as _rpc
from twisted.internet import reactor, task
from twisted.web import server as _server

CWD = os.getcwd()
MASTER = ()
SERVICE = None

# PYFARM_RESTART should not start out in the environment
if 'PYFARM_RESTART' in os.environ:
    del os.environ['PYFARM_RESTART']

class Host(_rpc.Service, _logger.Logger):
    '''
    Main xmlrpc service which controls the host.  Most methods
    are handled entirely outside of this class for the purposes of
    separation of service and logic.
    '''
    # provides a location to store our call to reactor.callLater
    def __init__(self):
        _logger.Logger.__init__(self, self)
        _rpc.Service.__init__(self, SERVICE_LOG)

        cmdargs.printOptions(options, self.debug)

        if options.verify_master:
            if not _rpc.ping(MASTER[0], MASTER[1]):
                raise errors.NetworkSetupError(
                    "failed to connect to master at %s:%s" % MASTER
                )

            try:
                online = query.master.online(MASTER[0])
                if not online:
                    raise errors.NetworkSetupError(
                        "%s:%s is not online but is reachable" % MASTER
                    )

            except errors.HostNotFound, error:
                raise errors.NetworkSetupError(error)
    # end __init__

    def xmlrpc_master(self):
        '''returns the current master'''
        return MASTER
    # end xmlrpc_master

    def _blockShutdown(self):
        return False
    # end _blockShutdown

    def _blockRestart(self):
        return self._blockShutdown()
    # end _blockRestart
# end Client

# create a lock for the process so we can't run two clients
# from the same host at once
with PROCESS_LOCK:
    # if the master has not been provided then
    # we should try and use the entry from the database
    master = master.get(options.master)
    master_port = query.master.port(master)
    MASTER = (master, master_port)

    # construct keyword arguments used to update the host in
    # the database
    host_table_keywords = {
        "ram_total" : options.ram,
        "cpu_count" : options.cpus,
        "online" : options.online,
        "groups" : options.groups,
        "software" : options.software,
        "port" : options.port
    }

    if options.store_master and options.master:
        host_table_keywords['master'] = options.master

    elif options.store_master and options.master is None:
        logger.warning("master will be set to None for %s" % FQDN)
        host_table_keywords['master'] = options.master

    if query.hosts.exists():
        logger.debug("updating %s in the host table" % FQDN)
        modify.host.host(
            FQDN,
            **host_table_keywords
        )

    else:
        logger.info("inserting %s into the host table" % FQDN)
        insert.host.host(**host_table_keywords)

    SERVICE = Host()

    # assign the host id
    network.HOSTNAME = query.hosts.hostid(network.FQDN)

    # schedule memory updates
    update_memory_task = task.LoopingCall(update_memory.update)
    update_memory_task.start(prefs.get('host.ram-update-interval'), now=False)

    # start listening for connections with the host
    reactor.listenTCP(options.port, _server.Site(SERVICE))

    # start reactor
    args = (FQDN, options.port)
    SERVICE.info("running host at http://%s:%i" % args)
    reactor.run()

    # set this host as offline
    SERVICE.debug("setting host as offline in database")
    modify.host.host(FQDN, online=False)

# If RESTART has been set to True then restart the host
# script.  This must be done after the reactor and has been
# shutdown and after we have given the port(s) a chance
# to release.
if os.environ.get('PYFARM_RESTART') == 'true' and prefs.get('network.rpc.restart'):
    pause = prefs.get('network.rpc.delay')
    SERVICE.debug("preparing to restart the host, pausing %i seconds" % pause)
    time.sleep(pause)
    args = sys.argv[:]

    args.insert(0, sys.executable)
    if OS == OperatingSystem.WINDOWS:
        args = ['"%s"' % arg for arg in args]

    os.chdir(CWD)
    os.execv(sys.executable, args)
