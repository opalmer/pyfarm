#!/usr/bin/env python
#
# This file is part of PyFarm.
# Copyright (C) 2008-2012 Oliver Palmer
#
# PyFarm is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PyFarm is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with PyFarm.  If not, see <http://www.gnu.org/licenses/>.

'''
receive, process, and handle job requests from the master
'''

import os
import sys
import time
import site
import threading

from twisted.internet import reactor, task
from twisted.web import server as _server

CWD = os.path.realpath(os.path.dirname(__file__))
ROOT = os.path.realpath(os.path.join(CWD, '..'))
PYTHONLIB = os.environ.get('PYFARM_PYTHONLIB') or os.path.join(ROOT, 'lib', 'python')
site.addsitedir(PYTHONLIB)

from pyfarm.master import cmdargs
from pyfarm import lock
from pyfarm import logger as _logger
from pyfarm.preferences import prefs
from pyfarm.datatypes.network import FQDN

# Handle command line input before importing anything else.  This
# ensures that if -h or --help is requested or if we have trouble
# parsing the arguments we can run the appropriate action before
# we setup other modules.
options = cmdargs.parser.parse_args()

if options.db is not None:
    prefs.set('database.setup.config', options.db)

# setup the process lock before starting the log
PROCESS_LOCK = lock.ProcessLock(
    'master',
    kill=options.force_kill, wait=options.wait,
    remove=options.remove_lock
)

# determine the location we should log to
if not options.log:
    root = prefs.get('filesystem.locations.general')
    SERVICE_LOG = os.path.join(root, 'master-%s.log' % FQDN)
else:
    SERVICE_LOG = os.path.abspath(options.log)

_logger.logger.addObserver(_logger.Observer(SERVICE_LOG))
logger = _logger.logger

from pyfarm.db import tables, query, modify, insert
from pyfarm.net import rpc as _rpc
from pyfarm.datatypes.network import IP, SUBNET
from pyfarm.datatypes.system import OS, OperatingSystem
from pyfarm.master import assign

SERVICE = None

# PYFARM_RESTART should not start out in the environment
if 'PYFARM_RESTART' in os.environ:
    del os.environ['PYFARM_RESTART']

# setup preferences
prefs.set('database.setup.close-connections', False)

class Master(_rpc.Service, _logger.Logger):
    '''
    Main master class to act as an external interface to the
    data base and job master.
    '''
    THREAD_LOCK = threading.Lock()
    def __init__(self):
        _logger.Logger.__init__(self, self)
        _rpc.Service.__init__(self, SERVICE_LOG)

        cmdargs.printOptions(options, self.debug)
        self.count = 0
        self.assign = assign.Assignment()
    # end __init__

    def xmlrpc_assign(self):
        '''assigns work to individual hosts'''
        if self.assign.shouldRun():
            reactor.callInThread(self.assign.run)
    # end xmlrpc_assign
# end Server

# create a lock for the process so we can't run two servers
# from the same host at once
with PROCESS_LOCK:
    # determine the location we should log to
    if not options.log:
        root = prefs.get('filesystem.locations.general')
        SERVICE_LOG = os.path.join(root, 'master-%s.log' % FQDN)
    else:
        SERVICE_LOG = os.path.abspath(options.log)

    SERVICE = Master()

    t = task.LoopingCall(SERVICE.xmlrpc_assign)
    t.start(prefs.get('master.assignment-interval'))

    # setup the required tables
    tables.init()

    master_table_data = {
        "port" : options.port,
        "online" : True,
        "queue" : options.queue,
        "assignment" : options.assignment,
        "ip" : IP,
        "subnet" : SUBNET
    }

    if query.master.exists(FQDN):
        update_function = modify.master.master

    else:
        update_function = insert.master.master

    # normally we would defer the database update
    # to a thread to prevent blocking for occurring
    # but in this case we can't really move on till this
    # completes
    update_function(FQDN, **master_table_data)

    # start the reactor
    reactor.listenTCP(options.port, _server.Site(SERVICE))
    SERVICE.info("running master at http://%s:%i" % (FQDN, options.port))
    reactor.run()

    # set this master as offline
    SERVICE.debug("setting master as offline in database")
    modify.master.master(FQDN, online=False)

# If RESTART has been set to True then restart the master
# script.  This must be done after the reactor and has been
# shutdown and after we have given the port(s) a chance
# to release.
if os.environ.get('PYFARM_RESTART') == "true":
    pause = prefs.get('network.rpc.delay')
    SERVICE.info("preparing to restart the master, pausing %i seconds" % pause)
    time.sleep(pause)
    args = sys.argv[:]

    args.insert(0, sys.executable)

    if OS == OperatingSystem.WINDOWS:
        args = ['"%s"' % arg for arg in args]

    os.chdir(CWD)
    os.execv(sys.executable, args)
