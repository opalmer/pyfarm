#!/usr/bin/env python
#
# Copyright 2013 Oliver Palmer
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

'''
receive, process, and handle job requests from the master
'''

import os
import sys
import time
import threading

from twisted.internet import reactor, task
from twisted.web import server as _server

CWD = os.path.realpath(os.path.dirname(__file__))

try:
    import pyfarm

except ImportError: # mainly for testing
    import site
    import warnings
    warnings.warn("adding PyFarm to the site packages", RuntimeWarning)
    root = os.path.realpath(os.path.join(CWD, '..'))
    sitedir = os.environ.get('PYFARM_PYTHONLIB') or \
              os.path.join(root, 'lib', 'python')

    if not os.path.isdir(sitedir):
        raise OSError(
            "no such directory %s, cannot add to site directory" % sitedir
        )
    site.addsitedir(sitedir)

from pyfarm.master import cmdargs
from pyfarm import lock
from pyfarm import logger as _logger
from pyfarm.preferences import prefs
from pyfarm.datatypes import network
from pyfarm.datatypes.enums import OperatingSystem

# Handle command line input before importing anything else.  This
# ensures that if -h or --help is requested or if we have trouble
# parsing the arguments we can run the appropriate action before
# we setup other modules.
options = cmdargs.parser.parse_args()

if options.db is not None:
    prefs.set('database.setup.config', options.db)

# setup the process lock before starting the log
PROCESS_LOCK = lock.ProcessLock(
    'master',
    kill=options.force_kill, wait=options.wait,
    remove=options.remove_lock
)

# determine the location we should log to
if not options.log:
    root = prefs.get('filesystem.locations.general')
    SERVICE_LOG = os.path.join(root, 'master-%s.log' % network.FQDN)
else:
    SERVICE_LOG = os.path.abspath(options.log)

_logger.logger.addObserver(_logger.Observer(SERVICE_LOG))
logger = _logger.logger
assignment_loop = None

from pyfarm.db import tables, query, modify, insert
from pyfarm.datatypes.network import IP, SUBNET
from pyfarm.datatypes.system import OS
from pyfarm.net.rpc.server.xmlservice import XMLRPCService
from pyfarm.master import assign

SERVICE = None

# PYFARM_RESTART should not start out in the environment
if 'PYFARM_RESTART' in os.environ:
    del os.environ['PYFARM_RESTART']

# setup preferences
prefs.set('database.setup.close-connections', False)

class Master(XMLRPCService, _logger.Logger):
    '''
    Main master class to act as an external interface to the
    data base and job master.
    '''
    THREAD_LOCK = threading.Lock()
    def __init__(self):
        _logger.Logger.__init__(self, self)
        XMLRPCService.__init__(self, SERVICE_LOG)

        cmdargs.printOptions(options, self.debug)
        self.count = 0
        self.assign = assign.Assignment()
    # end __init__

    def xmlrpc_assign(self):
        '''assigns work to individual hosts'''
        if self.assign.shouldRun():
            reactor.callInThread(self.assign.run)
    # end xmlrpc_assign

    def xmlrpc_assignment(self, enabled):
        '''enables or disables the assignment loop'''
        global assignment_loop

        if enabled and assignment_loop is None:
            assignment_loop = task.LoopingCall(SERVICE.xmlrpc_assign)
            assignment_loop.start(prefs.get('master.assignment-interval'))

        elif enabled and isinstance(assignment_loop, task.LoopingCall):
            if assignment_loop.running:
                self.debug("assignment loop is already running, nothing to do")
            else:
                self.info("restarting assignment loop")
                assignment_loop.start(assignment_loop.interval)

        elif not enabled and isinstance(assignment_loop, task.LoopingCall):
            if assignment_loop.running:
                assignment_loop.stop()
                self.info("assignment loop as been stopped")
            else:
                self.debug("nothing not stop, assignment loop not running")

        elif assignment_loop is None:
            self.info("nothing to do, assignment loop is None")
    # end xmlrpc_assignment
# end Server

# create a lock for the process so we can't run two servers
# from the same host at once
with PROCESS_LOCK:
    # determine the location we should log to
    if not options.log:
        root = prefs.get('filesystem.locations.general')
        SERVICE_LOG = os.path.join(root, 'master-%s.log' % network.FQDN)
    else:
        SERVICE_LOG = os.path.abspath(options.log)

    SERVICE = Master()

    if options.assignment:
        assignment_loop = task.LoopingCall(SERVICE.xmlrpc_assign)
        assignment_loop.start(prefs.get('master.assignment-interval'))

    # setup the required tables
    tables.init()

    master_table_data = {
        "port" : options.port,
        "online" : True,
        "queue" : options.queue,
        "assignment" : options.assignment,
        "ip" : IP,
        "subnet" : SUBNET
    }

    if query.master.exists(network.FQDN):
        update_function = modify.master.master

    else:
        update_function = insert.master.master

    # normally we would defer the database update
    # to a thread to prevent blocking for occurring
    # but in this case we can't really move on till this
    # completes
    result = update_function(network.FQDN, **master_table_data)
    if not result:
        raise ValueError("expected a result after the master update/insertion")

    network.HOSTID = result[0]

    # start the reactor
    reactor.listenTCP(options.port, _server.Site(SERVICE))
    SERVICE.info("running master at http://%s:%i" % (network.FQDN, options.port))
    reactor.run()

    # set this master as offline
    SERVICE.debug("setting master as offline in database")
    modify.master.master(network.FQDN, online=False)

# If RESTART has been set to True then restart the master
# script.  This must be done after the reactor and has been
# shutdown and after we have given the port(s) a chance
# to release.
if os.environ.get('PYFARM_RESTART') == "true":
    pause = prefs.get('network.rpc.delay')
    SERVICE.info("preparing to restart the master, pausing %i seconds" % pause)
    time.sleep(pause)
    args = sys.argv[:]

    args.insert(0, sys.executable)

    if OS == OperatingSystem.WINDOWS:
        args = ['"%s"' % arg for arg in args]

    os.chdir(CWD)
    os.execv(sys.executable, args)
